学习笔记

动态规划和递归或者分治没有根本上的区别

关键看有无最优子结构

如果没有最优子结构，说明所有的子问题都需要计算一遍，同时合并最后的结果（分治） 

共性：找到重复子问题

差异性：最优子结构，中途可以淘汰次优解 



斐波那契数列：

```text
dp方程：F[n] = F[n-1] + F[n-2]

a[0] = 0; 
a[1] = 1;
for(int i = 2; i <= n; ++i) {
	a[i] = a[i - 1] + a[i - 2];
}
a[n]
```



不同路径和：

对于任意一个点的走法数，就等于该点右边点的走法数+该点下边点的走法数，如果该点是一个障碍物，那它的走法数为0 

```text
第一列的格子只有从其上边格子走过去这一种走法，因此初始化dp[i][0]值为1
第一行的格子只有从其左边格子走过去这一种走法，因此初始化dp[0][j]值为1
dp方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```



最长公共子序列：

1.假设两个字符串都是空：最长子序列就是""

2.假设一个字符串是空，一个是任意字符串：最长子序列也是""

3.假设一个字符串是A，只要另一个字符串包含A，最长公共子序列长度就是1

4.S1 = ".....A", S2 = ".....A"从最后字符看起——>S1 A前子字符串和S2 A前子字符串的最长公共子序列数+1 

两种情况：

```java
// 如果s1和s2的最后一个字符不相同的话，那么他们之间的最长公共子序列的长度就等于s1去一个字符和s2来比，或者s2去一个字符和s1来比，
// 这两者之间的最长公共子序列的较大值
// lcs: longest common subsequance
if s1[n - 1] != s2[n - 1]:
    lcs[s1, s2] = Max(lcs[s1 - 1, s2], lcs[s1, s2 -1])
```

```java
// 如果s1和s2的最后一个字符相同，那么他们之间的最长公共子序列长度等于s1减去最后一个字符的子串和s2减去最后一个字符的子串
// 的最长公共子序列的长度 + 1
if s1[n - 1] == s2[n - 1]:
    lcs[s1, s2] = lcs[s1 -1, s2 -1] + 1
```

```text
最终结果就是dp[s1.length - 1][s2.length - 1]
```



三角形最小路径和 :

求顶点到最底层的最小路径和就是求从第二层的两个点到最底层的最小路径和的较小值 + 顶点的值

```text
1.分治: problem(i, j) = min(sub(i + 1, j + 1), sub(i + 1, j + 1)) + a[i , j]
2.定义状态数组：f[i, j]
3.dp方程：f[i, j] = min(f[i + 1, j], f[i + 1, j + 1]) + a[i, j]
```



最大子序列和：

最大子序和 = 当前元素自身最大（只包含当前元素），或者包含之前元素，再加自身后最大 

```text
从最后一个元素开始，针对每一个元素，包含取这个元素和不取这个元素两种情况，取这两种情况时子序列和的最大值
1.分治：max_sum(i) = Max(max_sum(i - 1) + a[i])
2.状态数组定义：f[i]
3.dp方程：f[i] = Max(f[i - 1], 0) + a[i]
```

